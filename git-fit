#!/usr/bin/env python2.7

from argparse import ArgumentParser
from os import getcwd, chdir, mkdir, chmod
from os.path import dirname, realpath, relpath, join as joinpath, exists
import sys
from subprocess import call
sys.path.append(joinpath(dirname(realpath(__file__)), 'bin'))
sys.path.append(joinpath(dirname(realpath(__file__)), 'stores'))
from sys import argv
from fit import fitDir, cacheDir, syncDir, repoDir, gitDir, tempDir
from fit import mergeMineFitFile, readFitFile, firstTimeFile, printAsText
import hooks, objects, merge, changes
import stat

def main():
    opts = getOpts()

    if merge.isMergeInProgress():
        if len(argv) != 2 or argv[1] != 'save':
            print merge.conflictMsg
            return

        fitTrackedData = readFitFile(mergeMineFitFile)
    else:
        fitTrackedData = readFitFile()

    if len(argv) > 1:
        if argv[1] in ('save', 'restore'):
            getattr(changes, argv[1])(fitTrackedData, pathArgs=opts.paths)
            exit()
        elif argv[1] in ('get', 'put'):
            objects.loadstore()
            kwd_args = {'summary':opts.summary, 'showlist':opts.list, 'quiet':opts.quiet}
            if argv[1] == 'get':
                kwd_args['pathArgs'] = opts.paths
            getattr(objects, argv[1])(fitTrackedData, **kwd_args)
            exit()

    firstTimeRepoSetup(fitTrackedData, opts.no_hooks)
    if not opts.git:
        changes.printStatus(fitTrackedData, pathArgs=opts.paths, legend=opts.legend, showall=opts.all)
    elif opts.git == 'pre-commit':
        hooks.preCommit(fitTrackedData)
    elif opts.git == 'post-commit':
        hooks.postCommit(fitTrackedData)
    elif opts.git == 'post-merge':
        hooks.postCheckout(fitTrackedData, 'HEAD@{1}')
    elif opts.git == 'post-checkout' and opts.paths[2] == '1' and opts.paths[0] != opts.paths[1]:
        hooks.postCheckout(fitTrackedData, opts.paths[0])
    elif opts.git == 'merge_driver':
        merge.mergeDriver(*(opts.paths[:3]))
    elif opts.git == 'text_output':
        printAsText(readFitFile(opts.paths[0]))

# This will be used to check whether we need to run (or re-run after changes to git-fit)
# this first-time repo setup
_firstTimeCounter = 0

def firstTimeRepoSetup(fitTrackedData, nohooks=False):
    global _firstTimeCounter
    if not exists(fitDir):
        print 'Preparing this repository for use with git-fit...'
        mkdir(fitDir)
        mkdir(cacheDir)
        mkdir(syncDir)
        mkdir(tempDir)
        changes.restore(fitTrackedData, quiet=True)
    elif exists(firstTimeFile):
        firstTimeCount = int(open(firstTimeFile).read())

        if firstTimeCount == _firstTimeCounter:
            return

        if firstTimeCount > _firstTimeCounter:
            print 'You are running a version of git-fit that is OLDER than the version with which'
            print 'this repo has been used before. Please check that your PATH points to the'
            print 'latest copy of git-fit you have on your system. git-fit will now exit...'
            exit(1)

    f = open(firstTimeFile, 'w')
    f.write("%d"%_firstTimeCounter)
    f.close()

    f = open(joinpath(gitDir, 'info', 'attributes'), 'w')
    f.write('\n.fit -fit merge=fitfile diff=fitfile\n')
    f.close()

    f = open(joinpath(gitDir, 'info', 'exclude'), 'w')
    f.write('\n.fit\n')
    f.close()

    if nohooks:
        return

    f = open(joinpath(gitDir, 'hooks', 'pre-commit'), 'w')
    f.write('\n$fitt --git=pre-commit\n')
    f.close()
    chmod(joinpath(gitDir, 'hooks', 'pre-commit'), stat.S_IRUSR | stat.S_IWUSR | stat.S_IXUSR)
    
    f = open(joinpath(gitDir, 'hooks', 'post-commit'), 'w')
    f.write('\n$fitt --git=post-commit\n')
    f.close()
    chmod(joinpath(gitDir, 'hooks', 'post-commit'), stat.S_IRUSR | stat.S_IWUSR | stat.S_IXUSR)

    f = open(joinpath(gitDir, 'hooks', 'post-checkout'), 'w')
    f.write('\n$fitt --git=post-checkout ${1} ${2} ${3}\n')
    f.close()
    chmod(joinpath(gitDir, 'hooks', 'post-checkout'), stat.S_IRUSR | stat.S_IWUSR | stat.S_IXUSR)

    f = open(joinpath(gitDir, 'hooks', 'post-merge'), 'w')
    f.write('\n$fitt --git=post-merge\n')
    f.close()
    chmod(joinpath(gitDir, 'hooks', 'post-merge'), stat.S_IRUSR | stat.S_IWUSR | stat.S_IXUSR)

    cmd = '''
        git config merge.fitfile.name 'Merge driver to auto-resolve .fit file conflicts when possible'
        git config merge.fitfile.driver '$fitt --git=merge-driver %O %A %B'
        git config diff.fitfile.textconv '$fitt --git=text-output'
        git config diff.fitfile.cachetextconv true
    '''
    call('set -e\n' + cmd, shell=True)

def getOpts():
    if len(argv) == 1 or argv[1] not in ('save', 'restore', 'get', 'put'):
        if '-h' in argv:
            print helpUsage
            exit()

        if '--help' in argv:
            print helpIntro + helpUsage + helpFull
            exit()
        parser = ArgumentParser(add_help=False, usage='git-fit [--help] [--legend] [--all] [<PATH>...]')
        parser.add_argument('--no-hooks', action='store_true')
        parser.add_argument('--git', choices=('post-commit','pre-commit','post-checkout','post-merge','merge-driver','text-output'))
        parser.add_argument('--all', '-a', action='store_true')
        parser.add_argument('--legend', '-l', action='store_true')
        parser.add_argument('paths', nargs='*')
        opts = parser.parse_args()
    elif argv[1] in ('save', 'restore'):
        usage = 'git-fit %s [--help] [<PATH>...]'%(argv[1])
        if '--help' in argv[2:]:
            print 'usage:', usage
            print (cmdSaveHelp if argv[1] == 'save' else cmdRestoreHelp)
            exit()
        if '-h' in argv[2:]:
            print 'usage:', usage
            exit()
        parser = ArgumentParser(add_help=False, usage=usage)
        parser.add_argument('paths', nargs='*')
        opts = parser.parse_args(argv[2:])
    elif argv[1] in ('get', 'put'):
        usage = 'git-fit %s [--help] %s'%(argv[1], cmdGetUsage if argv[1] == 'get' else cmdPutUsage)
        if '--help' in argv[2:]:
            print 'usage:', usage
            print (cmdGetHelp if argv[1] == 'get' else cmdPutHelp)
            print 'Options:',cmdGetPutOpts
            exit()
        if '-h' in argv[2:]:
            print 'usage:', usage
            exit()
        parser = ArgumentParser(add_help=False, usage=usage)
        parser.add_argument('--summary', '-s', action='store_true')
        parser.add_argument('--list', '-l', action='store_true')
        parser.add_argument('--quiet', '-q', action='store_true')
        if argv[1] == 'get':
            parser.add_argument('paths', nargs='*')
        opts = parser.parse_args(argv[2:])

    return opts

helpIntro='''
git-fit has five basic operations, status, save/restore, and get/put. All
operations except 'put' can optionally take one or more paths to select a
subset of items. Use -h/--help to get brief/detailed help on any operation.
Without any subcommand, git-fit shows the status of fit items.
'''

helpUsage='''
Usage:
    git-fit [<COMMAND>] [-h] [--help]

    git-fit         [--legend] [--all] [<PATH>...]
    git-fit save    [<PATH>...]
    git-fit restore [<PATH>...]
    git-fit get     [--summary] [--list] [--quiet] [<PATH>...]
    git-fit put     [--summary] [--list] [--quiet]
'''

cmdGetPutOpts='''
    -s, --summary   Do not transfer. Instead, show a summary of what would be transferred.
    -l, --list      Do not transfer. Instead, list all the items that would be transferred.
    -q, -quiet      Supress transfer progress output.
'''

helpFull='''
Commands:
    (none)    Shows status of fit items in the working tree.

    save      Updates .fit file with current changes to fit items in the working tree.
    restore   Discards any changes to fit items in the working tree. (opposite of save).
    get       Copies objects FROM remote location and/or populates working tree.
    put       Copies objects TO remote location from local cache.

Options:
    -h              Show brief help for the command.
    --help          Show full help for the command.

    status
    -l, --legend    Print a legend showing what status symbols mean.
    -a, --all       List even those items whose status is unchanged.

    get/put''' + cmdGetPutOpts

cmdGetUsage = '[--summary] [--list] [--quiet] [<PATH>...]'
cmdPutUsage = '[--summary] [--list] [--quiet]'
cmdSaveHelp = '''
Updates .fit file with current changes to fit items in the working tree. The .fit file will
also be git-added (which you can then commit along with any other non-fit changes). After
running this command, any items that were shown as modified, added, removed, or untracked
(*, +, -, ~) by the status output of git-fit will no longer be shown as such, since those
changes will have been saved in the .fit file. However, any potential commit-aborting items
will continue to be shown in the status.
'''
cmdRestoreHelp = '''
Discards any changes to fit items in the working tree. (THIS CANNOT BE UNDONE). Notice that
this operation is the opposite of the save operation. This will IRREVERSIBLY discard all
uncommitted changes to your fit-tracked items, bringing your working tree to a pristine
condition with respect to those objects currently being tracked by fit (so use this command
with caution). In other words, whatever modified, added, or removed (*, +, -) items you see in
the git-fit status output before running restore, you will no longer see after running
restore. Items marked to be untracked from fit (~) and any potential commit-aborting items will
continue to be shown and cannot be "restored".
'''
cmdGetHelp = '''
Copies objects FROM remote location and/or populates working tree. Until this is done, any
action in your project that requires the actual contents of these items will not work as
expected. Only items that are not already in the working tree or local fit cache will be
downloaded.
'''
cmdPutHelp = '''
Copies objects TO remote location from local cache. Until this is done, people who are using
your commits will not have access to these items. If an item already exist in the external
store due to a previous upload (either by you or someone else), the item will be skipped (but
this cannot be determined without actually starting the upload process first). Unlike git-fit
get, git-fit put does not take optional PATH arguments -- all items needing to be uploaded for
the HEAD must be uploaded to fulfill the commit.
'''

if __name__ == '__main__':
    main()
