#!/usr/bin/env python2.7

import argparse
from os import getcwd, chdir, mkdir, chmod
from os.path import dirname, realpath, relpath, join as joinpath, exists
import sys
sys.path.append(joinpath(dirname(realpath(__file__)), 'bin'))
sys.path.append(joinpath(dirname(realpath(__file__)), 'stores'))
from fit import fitDir, cacheDir, syncDir, repoDir, gitDir, readFitFile
import status, hooks, objects, paths
import stat


helpMsg='''
git fit [--legend] [<paths>...]

Show the fit state of the working copy and any detected problems. For any "git commit"
issued on the working copy, fit will automatically update the commit to properly associate
it with any changes to fit-managed items. Use the --legend option to not print an
explanatory legend with status symbol meanings.

git fit --restore

The "--restore" option will irreversibly discard all uncommitted changes to your
fit-managed items, bringing your working directory to a pristine condition (so use this
option with caution). In other words, whatever changes you see in the "git fit" status
output before running --restore, you will no longer see after running --restore.

git fit --get [-s] [<paths>...]

Begin the download of the missing, uncached items for the HEAD commit. Until this is done,
any action in your project that requires the actual contents of these items will not work
as expected. With the -s option, --get will only show a summary of what needs to be
transferred. Optional <paths> can be specified to selectively download only certain items.


git fit --put [-s]

Begin the upload of fit objects that have been committed to git but are not present in the
etxternal location. Until this is done, people who are using your commits will not have access
to these items. With the -s option, --put will only show a summary of what needs to be
transferred.
'''


def firstTimeRepoSetup():
    if exists(fitDir):
        return

    mkdir(fitDir)
    mkdir(cacheDir)
    mkdir(syncDir)

    f = open(joinpath(gitDir, 'info', 'attributes'), 'a')
    f.write('\n.fit -fit\n')
    f.close()

    f = open(joinpath(gitDir, 'info', 'exclude'), 'a')
    f.write('\n.fit\n')
    f.close()

    f = open(joinpath(gitDir, 'hooks', 'pre-commit'), 'a')
    f.write('\ngit fit --pre-commit\n')
    f.close()
    chmod(joinpath(gitDir, 'hooks', 'pre-commit'), stat.S_IRUSR | stat.S_IWUSR | stat.S_IXUSR)

    f = open(joinpath(gitDir, 'hooks', 'post-commit'), 'a')
    f.write('\ngit fit --post-commit\n')
    f.close()
    chmod(joinpath(gitDir, 'hooks', 'post-commit'), stat.S_IRUSR | stat.S_IWUSR | stat.S_IXUSR)


    f = open(joinpath(gitDir, 'hooks', 'post-checkout'), 'a')
    f.write('\ngit fit --post-checkout\n')
    f.close()
    chmod(joinpath(gitDir, 'hooks', 'post-checkout'),  stat.S_IRUSR | stat.S_IWUSR | stat.S_IXUSR)

    hooks.postCheckout(readFitFile())

if __name__ == '__main__':
    if len(sys.argv) > 1:
        if sys.argv[1] in ('-h', '--help'):
            print helpMsg
            exit(1)
    
    parser = argparse.ArgumentParser(prog='fit')

    group = parser.add_mutually_exclusive_group()
    group.add_argument('--restore', action='store_true')
    group.add_argument('--legend', action='store_true')

    group.add_argument('--get', action='store_true')
    group.add_argument('--put', action='store_true')
    parser.add_argument('-s', '--summary', action='store_true')

    # Undocumented --run-hook arguments. This allows git-hooking by simply
    # insering one-line commands like "git fit --run-hook-preCommit" into
    # the into the git hook scripts
    group.add_argument('--pre-commit', action='store_true')
    group.add_argument('--post-commit', action='store_true')
    group.add_argument('--post-checkout', action='store_true')

    parser.add_argument('paths', nargs='*')

    opts = parser.parse_args()

    fitTrackedData = readFitFile()
    validPaths = paths.getValidFitPaths(opts.paths, fitTrackedData) if opts.paths else fitTrackedData.keys()

    firstTimeRepoSetup()

    if opts.pre_commit:
        hooks.preCommit(fitTrackedData)
    elif opts.post_commit:
        hooks.postCommit(fitTrackedData)
    elif opts.post_checkout:
        hooks.postCheckout(fitTrackedData)
    elif opts.get:
        objects.loadstore()
        objects.get(fitTrackedData, validPaths, summary=opts.summary)
    elif opts.put:
        objects.loadstore()
        objects.put(fitTrackedData, summary=opts.summary)
    elif opts.restore:
        hooks.postCheckout(fitTrackedData)
    else:
        status.printStatus(fitTrackedData, validPaths, legend=opts.legend)

'''
- symlinks (just ignore for now)
- size warning/limiting/cleanup
'''
