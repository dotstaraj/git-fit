#!/usr/bin/env python2.7

import argparse
from os import getcwd, chdir, mkdir, chmod
from os.path import dirname, realpath, relpath, join as joinpath, exists
import sys
from subprocess import call
sys.path.append(joinpath(dirname(realpath(__file__)), 'bin'))
sys.path.append(joinpath(dirname(realpath(__file__)), 'stores'))
from fit import fitDir, cacheDir, syncDir, repoDir, gitDir
from fit import readFitFile, firstTimeFile, printAsText
import hooks, objects, merge, changes
import stat


helpMsg='''
git fit [--legend] [<paths>...]

Shows the fit state of the working tree and any detected problems. Use the --legend option to
print an explanatory legend with status symbol meanings. It is possible for any item to have
more than one status. For instance, if you commit a new fit file and then change it again
(without having yet run 'git fit put'), that item will show ^* as its status.

git fit save [<paths>...]

Updates fit with current working tree changes to fit-tracked items. This will update and
git-add the .fit file. After running this command, any items that were shown as modified,
added, removed, or untracked (*, +, -, ~) by the status output of git fit will no longer be
shown as such. However, commit-aborting items (!) and items that may need to be uploaded (^)
will continue to be shown in the status.

git fit restore [-f] [<paths>...]

Discards all fit-related changes in the working tree (THIS CANNOT BE UNDONE). This will
IRREVERSIBLY discard all uncommitted changes to your fit-tracked items, bringing your working
tree to a pristine condition with respect to those objects currently being tracked by fit (so
use this command with caution). In other words, whatever modified, added, or removed (*, +, -)
items you see in the "git fit" status output before running restore, you will no longer see
after running restore. Because of its destructive potential, the command must be run with the
-f option for it to actually affect your working tree (otherwise it will just show dry-run
summary and warning). The following changes will continue to be shown and cannot be "restored"
with this command: items marked to be untracked from fit (~), items that may need to be
uploaded (^), and any commit-aborting items (!).

git fit get [-s] [-q] [<paths>...]

Downloads the missing, uncached items for the HEAD commit. Until this is done, any action in
your project that requires the actual contents of these items will not work as expected. With
the -s option, only a summary of what needs to be transferred will be shown. Optional <paths>
can be specified to selectively download only certain items. Use -q to to turn off progress
output for transfers.

git fit put [-s] [-q]

Uploads fit items that have been committed to git but are not present in the external location.
Until this is done, people who are using your commits will not have access to these items. With
the -s option, only a summary of what may need to be transferred will be shown. Use -q to to
turn off progress output for transfers. If an item already exist in the external store due to a
previous upload (either by you or someone else), the item will be skipped (but this cannot be 
determined without actually starting the upload process first).
'''

# This will be used to check whether we need to run (or re-run after changes to git-fit)
# this first-time repo setup
_firstTimeCounter = 0

def firstTimeRepoSetup(fitTrackedData, nohooks=False):
    if not exists(fitDir):
        print 'Preparing this repository for use with git-fit...'
        mkdir(fitDir)
        mkdir(cacheDir)
        mkdir(syncDir)
        print 'Populating working tree with fit items...'
        changes.restore(fitTrackedData, quiet=True)
    elif exists(firstTimeFile):
        firstTimeCount = int(open(firstTimeFile).read())

        if firstTimeCount == _firstTimeCounter:
            return

        if firstTimeCount > _firstTimeCounter:
            print 'You are running a version of git-fit that is OLDER than the version with which'
            print 'this repo has been used before. Please check that your PATH points to the'
            print 'latest copy of git-fit you have on your system. git-fit will now exit...'
            exit(1)

    f = open(firstTimeFile, 'w')
    f.write("%d"%_firstTimeCounter)
    f.close()

    f = open(joinpath(gitDir, 'info', 'attributes'), 'w')
    f.write('\n.fit -fit merge=fitfile diff=fitfile\n')
    f.close()

    f = open(joinpath(gitDir, 'info', 'exclude'), 'w')
    f.write('\n.fit\n')
    f.close()

    if nohooks:
        return

    f = open(joinpath(gitDir, 'hooks', 'pre-commit'), 'w')
    f.write('\ngit fit --pre-commit\n')
    f.close()
    chmod(joinpath(gitDir, 'hooks', 'pre-commit'), stat.S_IRUSR | stat.S_IWUSR | stat.S_IXUSR)
    
    f = open(joinpath(gitDir, 'hooks', 'post-commit'), 'w')
    f.write('\ngit fit --post-commit\n')
    f.close()
    chmod(joinpath(gitDir, 'hooks', 'post-commit'), stat.S_IRUSR | stat.S_IWUSR | stat.S_IXUSR)

    f = open(joinpath(gitDir, 'hooks', 'post-checkout'), 'w')
    f.write('\ngit fit --post-checkout $1 $2 $3\n')
    f.close()
    chmod(joinpath(gitDir, 'hooks', 'post-checkout'), stat.S_IRUSR | stat.S_IWUSR | stat.S_IXUSR)

    cmd = '''
        git config merge.fitfile.name 'Merge driver to auto-resolve .fit file conflicts when possible'
        git config merge.fitfile.driver 'git fit --merge-driver %O %A %B'
        git config diff.fitfile.binary true
        git config diff.fitfile.textconv 'git fit --text-output'
        git config diff.fitfile.cachetextconv true
    '''
    call('set -e\n' + cmd, shell=True)

if __name__ == '__main__':
    if len(sys.argv) > 1:
        if sys.argv[1] in ('-h', '--help'):
            print helpMsg
            exit(1)
    
    parser = argparse.ArgumentParser(prog='fit')
    parser.add_argument('--no-hooks', action='store_true')

    group = parser.add_mutually_exclusive_group()
    group.add_argument('--legend', action='store_true')
    parser.add_argument('--all', action='store_true')
    group.add_argument('--save', action='store_true')
    group.add_argument('--restore', action='store_true')
    parser.add_argument('-f', '--force', action='store_true')

    group.add_argument('--get', action='store_true')
    group.add_argument('--put', action='store_true')
    parser.add_argument('-s', '--summary', action='store_true')
    parser.add_argument('-v', '--verbose', action='store_true')
    parser.add_argument('-q', '--quiet', action='store_true')

    # Undocumented --run-hook arguments. This allows git-hooking by simply
    # insering one-line commands like "git fit --run-hook-preCommit" into
    # the into the git hook scripts
    group.add_argument('--pre-commit', action='store_true')
    group.add_argument('--post-commit', action='store_true')
    group.add_argument('--post-checkout', action='store_true')
    group.add_argument('--merge-driver', action='store_true')
    group.add_argument('--text-output', action='store_true')

    parser.add_argument('remaining', nargs='*')

    opts = parser.parse_args()

    if opts.force and not opts.restore:
        print 'error: the -f/--force option can only be used with --restore'
        exit(1)
    if not opts.force and opts.restore:
        print 'The --restore option must be run together with -f/--force. To verify what objects'
        print 'would be affected by --restore -f, run git fit to output current status of objects.'
        exit()

    fitTrackedData = readFitFile()

    firstTimeRepoSetup(fitTrackedData, opts.no_hooks)

    if opts.pre_commit:
        hooks.preCommit(fitTrackedData)
    elif opts.post_commit:
        hooks.postCommit(fitTrackedData)
    elif opts.post_checkout:
        hooks.postCheckout(fitTrackedData, *(opts.remaining[:3]))
    elif opts.merge_driver:
        merge.mergeDriver(*(opts.remaining[:3]))
    elif opts.text_output:
        printAsText(opts.remaining[0])
    elif opts.get:
        objects.loadstore()
        objects.get(fitTrackedData, pathArgs=opts.remaining, summary=opts.summary, verbose=opts.verbose, quiet=opts.quiet)
    elif opts.put:
        objects.loadstore()
        objects.put(fitTrackedData, summary=opts.summary, verbose=opts.verbose, quiet=opts.quiet)
    elif opts.restore:
        changes.restore(fitTrackedData, pathArgs=opts.remaining)
    elif opts.save:
        changes.save(fitTrackedData, pathArgs=opts.remaining)
    else:
        changes.printStatus(fitTrackedData, pathArgs=opts.remaining, legend=opts.legend, showall=opts.all)
 